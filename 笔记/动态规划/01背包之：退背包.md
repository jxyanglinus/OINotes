---
tags:
  - 背包
---
## 例题

[P4141 消失之物 - 洛谷](https://www.luogu.com.cn/problem/P4141)
## 分析

首先，这道题一眼就可以看出 01 背包，但是，我们要考虑第 $i$ 件物品消失的情况。

首先最容易想到的办法，应该是做 $n$ 遍 01 背包，这样一来复杂度为 $O(n^2m)$，本题 $n, m \le 2000$ 的数据范围肯定超时~~原本的数据太水了，这样也能过，所以后来上了 Hack 就过不了了~~。

现在，我们引入退背包来解决这个问题。
## 退背包

我们考虑先忽略掉删除物品的限制，求出所有的方案数，然后再枚举删除哪个物品，减去不符合的方案数，便可得到答案，有点类似容斥。

我们设 $f[i][1]$ 表示装入物品总体积为 $i$，删除掉目前所枚举物品时的方案数。设 $f[i][0]$ 表示装入物品总体积为 $i$，未删除物品时的方案数。

那么首先计算所有 $f[i][0]$，即不删除任何物品的情况：

```cpp
f[0][1] = f[0][0] = 1; // 切记一定要初始化，体积为 0 时只有一种方案就是什么都不装
for (int i = 1; i <= n; i++) {  
    for (int j = m; j >= arr[i]; j--) {  
        f[j][0] = (f[j][0] + f[j - arr[i]][0]) % 10;  
    }  
}
```

求 $f[i][1]$，我们需要下面这个式子：
$$
f[i][1] = (f[i][0] - f[i - V_j][1]) \mod 10
$$
$V_j$ 表示当前枚举的物品 $j$ 的体积。为什么这样推呢？首先要明确，$f[i - V_j][1]$ 表示占用体积为 $i - V_j$，且不包含物品 $j$ 的方案数。减掉 $f[i - V_j][1]$，意味着减去所有加上物品 $j$ 就可以达到体积 $i$ 的方案。$\mod 10$ 是因为题目要求输出最后一位。

那么代码就可以写了：
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
		if (j >= arr[i]) {
			f[j][1] = (f[j][0] - f[j - arr[i]][1] + 10) % 10;
		} else { // 体积小于 arr[i] 直接继承 f[j][0] 即可。
			f[j][1] = f[j][0] % 10;
		}
		printf("%d", f[j][1]); // 滚动数组滚掉了表示物品的一维，所以在计算完后立刻输出。
	}
	printf("\n");
}
```
## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2005;
int n, m;
int arr[maxn];
int f[maxn][2];

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &arr[i]);
	}
	f[0][1] = f[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = m; j >= arr[i]; j--) {
			f[j][0] = (f[j][0] + f[j - arr[i]][0]) % 10;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (j >= arr[i]) {
				f[j][1] = (f[j][0] - f[j - arr[i]][1] + 10) % 10;
			} else {
				f[j][1] = f[j][0] % 10;
			}
			printf("%d", f[j][1]);
		}
		printf("\n");
	}
	return 0;
}
```
